#ifdef NDEBUG
#error Runtime assertions are unexpectedly disabled for this build.
#endif

#include <algorithm>
#include <cassert>
#include <iostream>
#include <vector>

namespace {
    enum Primality { prime, composite }; // prime must be listed first

    using Index = typename std::vector<Primality>::size_type;

    // Reads range of prime range upper bounds from standard input.
    std::vector<Index> read_bounds()
    {
        std::vector<Index>::size_type t {};
        std::cin >> t;
        
        std::vector<Index> bounds;
        bounds.reserve(t);

        while (t-- != 0u) {
            Index n {};
            std::cin >> n;
            bounds.push_back(n);
        }

        return bounds;
    }

    // Builds and returns a collection of prime numbers, generated by an
    // unoptimized Sieve of Eratosthenes.
    std::vector<Index> get_primes(const Index n)
    {
        std::vector<Primality> table (n + 1u);
        for (Index i {2u}; i <= n; ++i) {
            if (table[i] == Primality::prime) { // not yet found composite
                for (auto j = i * 2u; j <= n; j += i)
                    table[j] = Primality::composite;
            }
        }

        std::vector<Index> primes;
        for (Index k {2u}; k <= n; ++k)
            if (table[k] == Primality::prime) primes.push_back(k);

        return primes;
    }
}

int main()
{
    const auto values = read_bounds();
    assert(!values.empty());
    const auto max_value = *std::max_element(values.cbegin(), values.cend());
    const auto primes = get_primes(max_value);

    const auto p = primes.cbegin(), q = primes.cend();
    for (const auto n : values)
        std::cout << (std::binary_search(p, q, n) ? "Yes" : "No") << '\n';
}
